<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daniel blog</title>
    <description>Hi
</description>
    <link>http://localhost:4000/blog/</link>
    <atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 25 Jul 2021 21:55:13 +0900</pubDate>
    <lastBuildDate>Sun, 25 Jul 2021 21:55:13 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>Sequentialsearch</title>
        <description>&lt;h1 id=&quot;순차검색sequentialsearch&quot;&gt;순차검색(SequentialSearch)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;선형 검색 알고리즘(linear search algorithm)이라고도 하며, 특정한 값을 찾는 알고리즘의 하나다. 리스트에서 찾고자 하는 값을 맨 앞에서부터 끝까지 차례대로 찾아 나가는 것이다. 검색할 리스트의 길이가 길면 비효율적이지만, 검색 방법 중 가장 단순하여 구현이 쉽고 정렬되지 않은 리스트에서도 사용할 수 있다는 장점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int sequentialSearch(int[] arr, int key) {
    int arraySize = arr.length;
    for (int i = 0; i &amp;lt; arraySize; i++) {
        System.out.println(i+&quot;번째 : &quot;+arr[i]);
        if (arr[i] == key) {
            return i;
        }
    }
    return -1;
}

public static void main(String[] args) {
    int[] dataArray = {2, 80, 34, 3, 15, 77, 37, 12, 8, 3, 8};
    int searchKey = 12;
    sequentialSearch(dataArray, searchKey);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2021/SequentialSearch/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/SequentialSearch/</guid>
        
        
      </item>
    
      <item>
        <title>Interfacecollection</title>
        <description>&lt;h2 id=&quot;컬렉션-프레임워크collection-framework&quot;&gt;컬렉션 프레임워크(collection framework)&lt;/h2&gt;
&lt;h3 id=&quot;데이터를-저장하는-자료-구조와-데이터를-처리하는-알고리즘을-구조화하여-javautil-패키지로-구현해-놓은-컨테이너-클래스&quot;&gt;데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 java.util 패키지로 구현해 놓은 컨테이너 클래스.&lt;/h3&gt;

&lt;h4 id=&quot;컬렉션-프레임워크-구조-및-종류&quot;&gt;컬렉션 프레임워크 구조 및 종류&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Superinterfaces
    &lt;ul&gt;
      &lt;li&gt;Iterable
        &lt;ul&gt;
          &lt;li&gt;Collection 인터페이스에서 Iterable를 확장했는데 Iterable 인터페이스는 forEach(Consumer&amp;lt;? super T&amp;gt; action), Iterable(), spliterator() 메소드가 유일하다.
            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Collection&amp;lt;E&amp;gt; extends Iterable&amp;lt;E&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Subinterfaces
    &lt;ul&gt;
      &lt;li&gt;BeanContext&lt;/li&gt;
      &lt;li&gt;BeanContextServices&lt;/li&gt;
      &lt;li&gt;BlockingDeque&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
      &lt;li&gt;BlockingQueue&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
      &lt;li&gt;Deque&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;List&lt;E&gt;&amp;lt;/Strong&amp;gt;&lt;/E&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;NavigableSet&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Queue&lt;E&gt;&amp;lt;/Strong&amp;gt;&lt;/E&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Set&lt;E&gt;&amp;lt;/Strong&amp;gt;&lt;/E&gt;&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;SortedSet&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
      &lt;li&gt;TransferQueue&lt;E&gt;&lt;/E&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementing Classes
    &lt;ul&gt;
      &lt;li&gt;AbstractCollection&lt;/li&gt;
      &lt;li&gt;AbstractList&lt;/li&gt;
      &lt;li&gt;AbstractQueue&lt;/li&gt;
      &lt;li&gt;AbstractSequentialList&lt;/li&gt;
      &lt;li&gt;AbstractSet&lt;/li&gt;
      &lt;li&gt;ArrayBlockingQueue&lt;/li&gt;
      &lt;li&gt;ArrayDeque&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;AttributeList&lt;/li&gt;
      &lt;li&gt;BeanContextServicesSupport&lt;/li&gt;
      &lt;li&gt;BeanContextSupport&lt;/li&gt;
      &lt;li&gt;ConcurrentHashMap.KeySetView&lt;/li&gt;
      &lt;li&gt;ConcurrentLinkedDeque&lt;/li&gt;
      &lt;li&gt;ConcurrentLinkedQueue&lt;/li&gt;
      &lt;li&gt;ConcurrentSkipListSet&lt;/li&gt;
      &lt;li&gt;CopyOnWriteArrayList&lt;/li&gt;
      &lt;li&gt;CopyOnWriteArraySet&lt;/li&gt;
      &lt;li&gt;DelayQueue&lt;/li&gt;
      &lt;li&gt;EnumSet&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;HashSet&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;JobStateReasons&lt;/li&gt;
      &lt;li&gt;LinkedBlockingDeque&lt;/li&gt;
      &lt;li&gt;LinkedBlockingQueue&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;LinkedHashSet&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;LinkedTransferQueue&lt;/li&gt;
      &lt;li&gt;PriorityBlockingQueue&lt;/li&gt;
      &lt;li&gt;PriorityQueue&lt;/li&gt;
      &lt;li&gt;RoleList&lt;/li&gt;
      &lt;li&gt;RoleUnresolvedList&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Stack&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;SynchronousQueue&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Vector&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##자주쓰는컬렉션&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Interface : List, Queue, Set&lt;/li&gt;
  &lt;li&gt;Class : ArrayList, HashSet, LinkedList, LinkedHashSet, Stack, TreeSet, Vector&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2021/InterfaceCollection/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/InterfaceCollection/</guid>
        
        
      </item>
    
      <item>
        <title>Hashing</title>
        <description>&lt;h1 id=&quot;해싱&quot;&gt;해싱&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;해싱(hashing)&lt;/strong&gt; : 키값을 비교하여 찾는 방법이 아니라 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾는방법.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;해시테이블&lt;/strong&gt; : 해싱함수에 의해 계산된 주소의 위치항목을 저장한 표.&lt;br /&gt;
 n개의 버킷과 m개의 슬롯으로 구성한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해싱-검색-방법&quot;&gt;해싱 검색 방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;해싱검색은 해싱함수를 계산하여 구한 주소 주소가 해시테이블에 있는지 검색.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  자리지정을 위한 학번(키값)입력 ► 자리지정(해싱함수) ► 강의실(해시테이블) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해싱구조&quot;&gt;해싱구조&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;동거자&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 서로 다른 키값을 가지지만 해싱함수에 의해서 같은 버킷에 저장긴 키값들.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;충돌&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 서로 다른 키값에 대해서 함수에 의해 버킷주소가 같은 경우.&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 포화버킷 상태에서 같은 버킷주소에 키값이 지정받고 충돌이 발생하면 오버플로우가된다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;키값밀도&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 현재 해시테이블에 저장되어 실제 사용되고 있는 키값의 갯수의 정도&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 키값밀도 = 실제 사용중인 키값의 개수 / 사용 가능한 키값의 개수&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;적재밀도&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt; 해시테이블에 저장이전 실제로 테이블에 저장되고 저장된것을 사용되는 키값의 갯수의 정도 &lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  □ 적재밀도 
  = 실제 사용중인 키값의 개수 / 저장 가능한 전체 키값의 개수  
  = 실제 사용중인 키값의 개수 / 버킷 개수 * 슬롯 개수
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;해싱함수&quot;&gt;해싱함수&lt;/h2&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;□ 키값을 원소의 위치로 변환하는 함수. 0 ~ N-1 사이의 버킷주소를 만듬.
□ 좋은해싱조건 : 쉬운계산, 적은충돌
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;중간제곱함수&lt;/strong&gt; : 키값을 제곱한 결과값에서 중간에 있는 적당한? 비트를 주소로 사용하는방법.&lt;br /&gt;
ex) &lt;u&gt;00110101 10100111 ^ = _00010110011**11101001**001011110001_ 
가운데 _11101001_ 의 10진수 233이 해시테이블의 버킷주소가된다.&lt;/u&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;제산함수&lt;/strong&gt; : 나머지 연산자 mod를 사용하요 키값k를 해시테이블의 크기 M으로 나눈 나머지를 해시주소로 사용하는방법. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h(k) = k mod M&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;승산함수&lt;/strong&gt; : 곱하기연산을 사용하는 방법으로 키값k와 정해진실수 A를 곱한 결과에서 소수점 이하부분만을 테이블의 크기 M과 곱하여 그 정수값을 주소로 사용하는 방법. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h(k) = (xA mod 1) * M&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;접지함수&lt;/strong&gt; : 키의 비트수가 해시테이블의 인덱스 비트수보다 큰 경우에 주로 사용하는방법.&lt;br /&gt;
&lt;span style=&quot;color:gray&quot;&gt;&lt;em&gt;이동접지함수&lt;/em&gt;&lt;/span&gt; - 인덱스자릿수로 키값을 끝까지 쪼개어진 수들을 더한값을 주소로함.&lt;br /&gt;
&lt;span style=&quot;color:gray&quot;&gt;&lt;em&gt;경계접지함수&lt;/em&gt;&lt;/span&gt; - 인덱스자릿수로 키값을 끝까지 쪼개어진 수들의 각 경계를 기준으로 접어서 더한값을 주소로함.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;숫자분석함수&lt;/strong&gt; : 키값을 이루고 있는 각자릿수의 분포를 분석하여 고르게 분포된 숫자를 조합 하여 해시주소로 사용하는방법. ex) &lt;u&gt;학번[200804112] : 2008(년도) 04(학과) 1(주/야간) 12(학생번호) 이 중 고르게분포된 [주/야간 번호 + 학생번호]를 조합한 숫자로 해시테이블 주소로 만든다.&lt;/u&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;진법변환함수&lt;/strong&gt; : 키값이 10진수가아닌 다른 진수일때 10진수로 변환하고 해시테이블주소로 필요한 자릿수만큼만 하위 자릿수를 사용하는방법.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비트추출함수&lt;/strong&gt; : 해시테이블크기가 2^k 일때 키값을 이진비트로 놓고 임의의 위치에 있는 비트들을 추출하여 주소로 사용하는방법.(충돌가능성이 많아 사전에 비트분석필요)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;오버플로우-처리방법&quot;&gt;오버플로우 처리방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;선형개방주소법&lt;/strong&gt; :  해당 버킷에 빈슬롯이 없어서 오플발생하면 다음버킷에 빈슬롯을 순차적으로 찾는방법.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;체이닝&lt;/strong&gt; : 해시테이블의 구조를 변경하여 각 버킷에 하나이상의 키값을 저장할 수 있도록 하는방법.&lt;br /&gt;
버킷에 슬롯을 동적으로 삽입,삭제하기 위해서 연결리스트를 사용하여 선형검색한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2021/Hashing/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/Hashing/</guid>
        
        
      </item>
    
      <item>
        <title>Binarysearchtree</title>
        <description>&lt;h1 id=&quot;이진트리검색binarytreesearch&quot;&gt;이진트리검색(BinaryTreeSearch)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2021/BinarySearchTree/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/BinarySearchTree/</guid>
        
        
      </item>
    
      <item>
        <title>Binarysearch</title>
        <description>&lt;h1 id=&quot;이진검색binarysearch&quot;&gt;이진검색(BinarySearch)&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;검색 원리상 정렬된 리스트에만 사용할 수 있다는 단점.&lt;/li&gt;
  &lt;li&gt;이진 탐색은 ‘퀵정렬’과 유사하게 ‘분할 후 정복(divide and conquer)’의 전략을 사용한다. 이 전략을 사용하는 알고리즘은 문제를 나누어 해결해 나가는 방법이기 때문에 실행시간은 log의 설징을 갖는다. 특히 문제의 크기를 정확히 양분하는 경우에는 최악의 경우라고 logN의 성능을 보장한다.
데이터의 순서가 오름차순으로 되어있기 때문에 왼쪽은 중앙요소보다 작고, 오른쪽은 큽니다. 검색하려는 데이터가 중앙값보다 크다면 오른편에서 중앙 요소를 다시 선택합니다. 그리고 다시 이진 탐색을 시작합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public static void main(String[] args) {
    int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    System.out.println(&quot;binarySearch(4) : &quot; + binarySearch(array, 4, array[0], array[array.length - 1]));
    System.out.println(&quot;---------------------------------------------&quot;);
    System.out.println(&quot;binarySearch(2) : &quot; + binarySearch(array, 4));
}

public static int binarySearch(int array[], int value) {
    int low = 0;
    int high = array.length - 1;
    while (low &amp;lt;= high) {
        int mid = (low + high) / 2;
        System.out.println(&quot;index value : &quot; + mid);
        if (array[mid] &amp;gt; value)
            high = mid - 1;
        else if (array[mid] &amp;lt; value)
            low = mid + 1;
        else
            return mid; // found
    }
    return -1; // not found
}

public static int binarySearch(int array[], int value, int low, int high) {
    if (high &amp;lt;= low)
        return -1; // not found

    int mid = (low + high) / 2;

    System.out.println(&quot;index value : &quot; + mid);

    if (array[mid] &amp;gt; value)
        return binarySearch(array, value, low, mid - 1);
    else if (array[mid] &amp;lt; value)
        return binarySearch(array, value, mid + 1, high);
    else
        return mid; // found
}


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 25 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/blog/2021/BinarySearch/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2021/BinarySearch/</guid>
        
        
      </item>
    
      <item>
        <title>Two Thousand Nineteen</title>
        <description>&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.&lt;/p&gt;
</description>
        <pubDate>Sat, 29 Jun 2019 03:52:21 +0900</pubDate>
        <link>http://localhost:4000/blog/2019/hello-world/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2019/hello-world/</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>Welcome to Docsy Jekyll</title>
        <description>&lt;p&gt;You’ll find this post in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;Tom&apos;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints &apos;Hi, Tom&apos; to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;

</description>
        <pubDate>Fri, 28 Jun 2019 19:52:21 +0900</pubDate>
        <link>http://localhost:4000/blog/2019/welcome/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2019/welcome/</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
