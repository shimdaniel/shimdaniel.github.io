# 해싱 
- __해싱(hashing)__ : 키값을 비교하여 찾는 방법이 아니라 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 찾는방법.
- __해시테이블__ : 해싱함수에 의해 계산된 주소의 위치항목을 저장한 표.  
 n개의 버킷과 m개의 슬롯으로 구성한다.

## 해싱 검색 방법 
- 해싱검색은 해싱함수를 계산하여 구한 주소 주소가 해시테이블에 있는지 검색.
	 
		자리지정을 위한 학번(키값)입력 ► 자리지정(해싱함수) ► 강의실(해시테이블) 
		
## 해싱구조
- 동거자  
``` > 서로 다른 키값을 가지지만 해싱함수에 의해서 같은 버킷에 저장긴 키값들. ```  

- 충돌  
``` > 서로 다른 키값에 대해서 함수에 의해 버킷주소가 같은 경우.```  
``` > 포화버킷 상태에서 같은 버킷주소에 키값이 지정받고 충돌이 발생하면 오버플로우가된다. ```  

- 키값밀도  
``` > 현재 해시테이블에 저장되어 실제 사용되고 있는 키값의 갯수의 정도 ```  
``` > 키값밀도 = 실제 사용중인 키값의 개수 / 사용 가능한 키값의 개수 ```  

- 적재밀도  
``` > 해시테이블에 저장이전 실제로 테이블에 저장되고 저장된것을 사용되는 키값의 갯수의 정도  ```  

		□ 적재밀도 
		= 실제 사용중인 키값의 개수 / 저장 가능한 전체 키값의 개수  
		= 실제 사용중인 키값의 개수 / 버킷 개수 * 슬롯 개수

## 해싱함수
```
□ 키값을 원소의 위치로 변환하는 함수. 0 ~ N-1 사이의 버킷주소를 만듬.
□ 좋은해싱조건 : 쉬운계산, 적은충돌
``` 
- __중간제곱함수__ : 키값을 제곱한 결과값에서 중간에 있는 적당한? 비트를 주소로 사용하는방법.  
ex) <U>00110101 10100111 ^ = _00010110011**11101001**001011110001_ 
가운데 _11101001_ 의 10진수 233이 해시테이블의 버킷주소가된다.</U>
- __제산함수__ : 나머지 연산자 mod를 사용하요 키값k를 해시테이블의 크기 M으로 나눈 나머지를 해시주소로 사용하는방법. ```h(k) = k mod M```
- __승산함수__ : 곱하기연산을 사용하는 방법으로 키값k와 정해진실수 A를 곱한 결과에서 소수점 이하부분만을 테이블의 크기 M과 곱하여 그 정수값을 주소로 사용하는 방법. ```h(k) = (xA mod 1) * M```
- __접지함수__ : 키의 비트수가 해시테이블의 인덱스 비트수보다 큰 경우에 주로 사용하는방법.  
<span style="color:gray">_이동접지함수_</span> - 인덱스자릿수로 키값을 끝까지 쪼개어진 수들을 더한값을 주소로함.  
<span style="color:gray">_경계접지함수_</span> - 인덱스자릿수로 키값을 끝까지 쪼개어진 수들의 각 경계를 기준으로 접어서 더한값을 주소로함.
- __숫자분석함수__ : 키값을 이루고 있는 각자릿수의 분포를 분석하여 고르게 분포된 숫자를 조합 하여 해시주소로 사용하는방법. ex) <U>학번[200804112] : 2008(년도) 04(학과) 1(주/야간) 12(학생번호) 이 중 고르게분포된 [주/야간 번호 + 학생번호]를 조합한 숫자로 해시테이블 주소로 만든다.</U>
- __진법변환함수__ : 키값이 10진수가아닌 다른 진수일때 10진수로 변환하고 해시테이블주소로 필요한 자릿수만큼만 하위 자릿수를 사용하는방법.
- __비트추출함수__ : 해시테이블크기가 2^k 일때 키값을 이진비트로 놓고 임의의 위치에 있는 비트들을 추출하여 주소로 사용하는방법.(충돌가능성이 많아 사전에 비트분석필요)

## 오버플로우 처리방법
- __선형개방주소법__ :  해당 버킷에 빈슬롯이 없어서 오플발생하면 다음버킷에 빈슬롯을 순차적으로 찾는방법.
- __체이닝__ : 해시테이블의 구조를 변경하여 각 버킷에 하나이상의 키값을 저장할 수 있도록 하는방법.  
버킷에 슬롯을 동적으로 삽입,삭제하기 위해서 연결리스트를 사용하여 선형검색한다.
