<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daniel Blog</title>
    <description>Back-End Engineer :)
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 01 Aug 2021 22:39:12 +0900</pubDate>
    <lastBuildDate>Sun, 01 Aug 2021 22:39:12 +0900</lastBuildDate>
    <generator>Jekyll v3.9.0</generator>
    
      <item>
        <title>JVM Structure</title>
        <description>&lt;h1 id=&quot;gc-basic&quot;&gt;GC Basic&lt;/h1&gt;

&lt;h2 id=&quot;소개&quot;&gt;소개&lt;/h2&gt;
&lt;p&gt;C언어의 가비지 수집은 코드에서 데이터를 수동으로 그리고 명시적으로 메모리를 할당하고 해제한다.
후에 사용되지 않은 메모리가 남용되면 결국 메모리 누수로 전락된다.
하지만 메모리를 비운다는 것은 사실상 쉽다. 코드상에서 충분히 제어가 가능하기때문이다. 
그런데 복잡한 프로그램상에 일일히 관리하기엔 신경써야할 코드가 너무 많기 때문에 훨씬 더 나은 접근 방법으로 
사용되지 않는 메모리를 효율적으로 관리하는 방법은 그것을 자동화하여 사람의 코드상에 실수의 가능성을 없애는 것! 
바로 이것이 “자동화 된 가비지 수집” 이다. (GC)
자바는 객체가 생성되면 자동으로 메모리를 할당하고 특정 객체가 더 이상 사용되지 않을 때 메모리를 자동으로 회수한다. 
메모리관리 작업을 자동으로 수행해 주기 때문에 C언어와 비교해 프로그램 상에서 메모리관리에는 조금 둔해지는것 같다. 
자바의 메모리관리는 시스템에 안정성에 있어 분명한 옵션으로 보인다. 
서비스의 성격에 따라 옵션의 수치들은 해당 시스템에 영향을 주는건 불가피하지만, 문자 그대로 그냥 옵션..
서비스를 운용하기 앞서 GC에 대한 인식을 정확히 짚고 넘어 갈 필요가 있다.
jvm과 GC의 대략적인 개념과 동작원리를 정리하고, 자바 구현과의 상관관계를 정리하였다.&lt;/p&gt;

&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;수많은 자바라이브어리들과 서비스들이 효율적인 GC영역은 어떤구현이 되어있으며 어떤 옵션들로 메모리영역들을 관리 및 구현이 되어있는지 상당한 부분에 기본적인 개념이 많이부족하다느꼈다. 그래서 이해를 돕기위한 선행학습으로 구체적인 내부구조를 간략하게 정리해보았다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;jvmjava-virtual-machine-기본구조-및-동작원리&quot;&gt;JVM(Java Virtual Machine) 기본구조 및 동작원리&lt;/h2&gt;
&lt;p&gt;메모리 영역을 체계적이고 자체 상호 명령으로 관리 되다보니 가상머신이란 이름이 붙여졌다. 자바로 작성된 소스 코드를 가상머신이 이해할 수 있는 중간 코드로 컴파일한 바이트코드(Bytecode)를 하드웨어 아키텍처에 맞는 기계어로 다시 컴파일하여 실행하는 장치로써 모든 OS에서 구분없이 실행가능하다. 크게 Class Loader, Execution Engine, Garbage Collector, Runtime Data Area 로 구성되며 Class Loader는 말그대로 클래스파일 “적재”용이다. “$JAVA_HOME\jre&quot; 이하에서 실행되는데 그 중 부트스트랩 클래스로더, 확장 클래스로더, 시스템 클래스로더의 각 로드의 역할로 java.ext.dirs의 시스템 속성에 지정된 디렉터리에 코드를 로드(적재)하여 Runtime Data Area에서 필요한 데이터를 가져다 쓰는 형태이다. 이 후 Execution Engine 이 자바 바이트코드를 실행하고 Garbage Collector로 메모리를 관리한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# .class &amp;lt;-&amp;gt; Class Loader &amp;lt;-&amp;gt; .jar(.class)
# Runtime Data Area
- method-area : 메소드바이트코드, 클래스/인터페이스/메소드/필드 정보, 접근제어자, 리턴타입, 타입정보, 
상수정보, Static/final class 변수 등이 저장됨.
- stack-area : Thread 제어를 위해 사용되는 메모리 영역으로 메소드의 매개변수, 지역변수, 반환값, 임시변수, 로컬 변수 및 
부분 결과를 보유하고 해당 메소드 관련 정보와 호출을 한 주소를 저장한다.
- heap-area : 모든 클래스 인스턴스/객체 및 배열에 대한 메모리
- pc-register : JVM의 PC-Register는 CPU에서 직접 명령을 수행하지 않는 Stack Base로 Stack에서 피연산자를 뽑아내어 PC-Register라는 
별도의 메모리 공간에 저장한후 CPU에 그명령을 전달한다.
- native-method-stacks : C, C++같은 언어로 구현된 메소드, 주로 하드웨어에 대한 접근용 메소드
# Execution Engine(JIT, GC) &amp;lt;-&amp;gt; # native-method-interface &amp;lt;-&amp;gt; # naticve-method-library
# 실행엔진 (Execution Engine) : 바이트코드를 명령어단위로 하나씩 인터프리팅된 결과를 실행하거나, JIT(Just In Time)컴파일러를 통해
바이트코드 전체를 컴파일하여 네이티브 코드로 변경 후 캐시에 저장하여 실행한다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heap-area-구조-및-gc-과정&quot;&gt;Heap area 구조 및 GC 과정&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Runtime Data Area 중에서 Heap area은 GC의 주요 대상이며, Young, Old, Permanent Generation 로 구성되었다. 
    Young Generation은 젊은객체 즉, 생명주기가짧고 사용빈도가 일정 횟수 이하인 객체들로 위치하는 공간으로
    Eden과 두개의 Survivor 공간(From-Survivor, To-Survivor)으로 이루어졌다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Eden은 new로 생성된 Java오브젝트의 인스턴스가 저장되며 해당 공간이 가득차면 From-Survivor에 복사되어 저장된다.
    그리고 From-Survivor가 가득차면 To-Survivor로 이동되는데 여기까지의 동작이 Minor GC 다.
    Young Generation 공간이 모두 차게 되면 Garbage Collector는 가용 메모리를 확보하기 위해 Major GC를 수행하는데 To-Survivor에서
    Old Generation로 이동된다. 여기서 이동 될 객체의 기준은 참조된 객체의 상태인데 판별을 위해 Mark and Sweep 알고리즘이 사용된다. 
    GC가 시작되면 먼저 모든 루트를 열거 한 다음 재귀적으로 참조되는 객체를 방문하기 시작한다. 메모리 그래프에서 노드를 이동해가며 객체에 도달하면 참조여부를 판단해 
    Live객체면 가비지가 아니라는 것을 표시한다. 이단계가 “Mark”이며 비트플래그로 표시되는데 이 단계에 reachability 이란 개념으로 unreachable를 구분하여 GC 처리한다.
    과정중에 힙 내의 다른 객체에 의한 참조, Java 메서드 실행 시에 사용하는 지역 변수와 파라미터들에 의한 참조, JNI(Java Native Interface)에 의해 생성된 
    객체에 대한 참조, 메서드 영역의 정적 변수에 의한 참조로 힙내의 다른객체에 의한 참조 중에 ‘힙 내의 다른 객체에 의한 참조’를 제외한 모든 참조를 
    “root set(최초참조)” 으로 기준삼아 시작한 참조 사슬에 속한 객체들과 그렇지 않은 객체로 reachable 객체와 unreachable 객체로 나눈다. 
    이 최초참조 사슬에 속한 객체들 중에서도 해당 객체의 유형을 강약으로 포지셔닝했는데 Strong reference &amp;gt; Soft reference &amp;gt; Weak reference &amp;gt;
    Phantom reference 순으로 객체를 정의하여 GC에 우선순위로 결정되는데 “root set”의 기준으로 참조된 객체는 Strong reference으로 
    GC대상에서 제외되고 그 외 Soft, Weak, Phantom 은 unreachable 객체로 GC 대상이된다.
    Soft, Weak, Phantom reference는 java.lang.ref 패키지로 일반적인 주소참조가아닌 특별한 참조 구성을 위한 Reference Object API는 객체를 가리키는 
    특별한 참조를 통하여 프로그램상에서 GC를 연계할수있다. 메모리상에 많은 객체를 갖거나 객체가 반환전에 정리작업을 위해 사용되는 객체의 reachability를 조절하며 
    동작을 다르게 지정하여 GC대상 여부를 판별하는 부분에 사용자 코드로써 직접적인 개입이 가능하다.  이 후 마크 단계가 끝나면 “Sweep” 단계가 된다. 
    이 단계까지 “Mark”되지 않은 메모리의 객체는 모두 가비지이며 “Sweep”은 전체 메모리를 반복하여 “Mark”되지 않은 메모리 블록을 해제한다. 
    그리고 매번 GC수행시에 JVM은 객체를 이동시키고 참조를 업데이트해야한다. 그 과정에 업데이트된 참조가 객체가 이동하지 않은 상태에서 이동을 시도하면 문제가 되어 
    GC쓰레드 이 외 모든 쓰레드를 잠시 동결시킨다. 이것을 STW(Stop The World) 라고 불리는데, STW가 결국 Serial, Parallel, Parallel, 
    Concurrent Mark &amp;amp; Sweep, G1 GC방식 들을 이용한 옵션들로 GC성능을 일부제어한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;other-gc-collections&quot;&gt;Other GC Collections&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;http://openjdk.java.net&lt;/li&gt;
  &lt;li&gt;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6668279&lt;/li&gt;
  &lt;li&gt;http://www.kdgregory.com/index.php?page=java.refobj&lt;/li&gt;
  &lt;li&gt;https://d2.naver.com/helloworld/329631&lt;/li&gt;
  &lt;li&gt;https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/garbage_collect.html#wp1086917&lt;/li&gt;
  &lt;li&gt;https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 01 Aug 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2021/08/01/dev-basic-gc/</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2021/08/01/dev-basic-gc/</guid>
        
        <category>dev</category>
        
        <category>basic</category>
        
        <category>gc</category>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>SonarQube docker install</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube.png&quot; alt=&quot;그림1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;코드정적분석sonarqube&quot;&gt;코드정적분석(SonarQube)&lt;/h1&gt;

&lt;h1 id=&quot;하드웨어-요구사항&quot;&gt;하드웨어 요구사항&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;최소 2GB의 RAM&lt;/li&gt;
  &lt;li&gt;1 vcpu 용량 서버&lt;/li&gt;
  &lt;li&gt;OpenJDK 11/JRE 11&lt;/li&gt;
  &lt;li&gt;EC2[t3a.medium]&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;설치&quot;&gt;설치&lt;/h1&gt;

&lt;blockquote&gt;
  &lt;p&gt;Java 환경설정
H2 DB 설치
SonarQube DB 스키마 생성
SonarQube DB 계정 생성 및 권한 설정
SonarQube 설치
SonarQube DB 기본 설정 등 Docker Image에 기능 포함됨&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;docker-설치&quot;&gt;Docker 설치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;서버업데이트 : sudo yum -y upgrade&lt;/li&gt;
  &lt;li&gt;도커설치 : sudo amazon-linux-extras install -y docker&lt;/li&gt;
  &lt;li&gt;도커확인 : docker –version&lt;/li&gt;
  &lt;li&gt;도커시작 : sudo systemctl start docker&lt;/li&gt;
  &lt;li&gt;권한부여 : sudo usermod -aG docker ec2-user&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sonarqube-container-설치&quot;&gt;SonarQube Container 설치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;설치 : docker run -d –name sonarqube -p 9000:9000 -p 9092:9092 sonarqube&lt;/li&gt;
  &lt;li&gt;시작 : docker start sonarqube&lt;/li&gt;
  &lt;li&gt;종료 : docker stop sonarqube&lt;/li&gt;
  &lt;li&gt;확인1 : docker ps -a&lt;/li&gt;
  &lt;li&gt;확인2 : http://[설치서버도메인]:9000&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sonarqube-기본-설정&quot;&gt;SonarQube 기본 설정&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;로그인 : 기본 ID/PW [admin/admin]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-1.png&quot; alt=&quot;https://https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-1.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-1.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;로그인 : 현재 ID/PW [admin/모빌러.11Q]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-3.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-3.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sonarqube-프로젝트-생성&quot;&gt;SonarQube 프로젝트 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:9000/admin&quot;&gt;Administration&lt;/a&gt; &amp;gt; Projects(Management) &amp;gt; Create Project&lt;/li&gt;
  &lt;li&gt;Name : Project name&lt;/li&gt;
  &lt;li&gt;Key : Project mapping key&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sonarqube-authorization-key-발급&quot;&gt;SonarQube authorization key 발급&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:9000/admin&quot;&gt;Administration&lt;/a&gt; &amp;gt; Security(Users) &amp;gt; Tokens &amp;gt; Generate Tokens&lt;/li&gt;
  &lt;li&gt;Token name : sonar_token&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sonarqube---jenkins-연동&quot;&gt;SonarQube - Jenkins 연동&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;프로젝트 최상위 ROOT 경로에  sonar-project.properties  추가&lt;/li&gt;
  &lt;li&gt;sonar.projectKey, sonar.projectName : 해당 프로젝트키, 이름&lt;/li&gt;
  &lt;li&gt;sonar.java.binaries : 해당 프로젝트 정적검사 대상  build class path&lt;/li&gt;
  &lt;li&gt;sonar.exclusions : 해당 프로젝트 정적검사 제외 path or file&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sonar.login&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;5211c402aeee68c59bd8e507d5ebf9b282f973a0
sonar.projectKey&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;sonar:XXXX
sonar.projectName&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;XXXX
sonar.host.url&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://localhost:9000/
sonar.java.binaries&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx-api/build/classes/java/main/xxx/xxx/xxx
sonar.exclusions&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx-api/src/main/resources/static/docs/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  ,xxxx-api/build/classes/java/test/xxx/xxx/xxx/service/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  ,xxxx-api/src/test/java/xxx/xxx/xxx/service/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  ,xxxx-api/src/test/&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
sonar.projectVersion&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.0
sonar.sourceEncoding&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;UTF-8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Project build : SonarQube Quality Gate [OK]&lt;/li&gt;
  &lt;li&gt;Project quality : Left menu[SonarQube] or [OK] Click!!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-7.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-7.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;sonarqube-공식-사용자-가이드&quot;&gt;SonarQube 공식 사용자 가이드&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.sonarqube.org/latest/&quot;&gt;https://docs.sonarqube.org/latest/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jacoco-code-coverage-reports-to-jenkins--sonarqube&quot;&gt;JaCoCo code coverage reports to Jenkins &amp;amp; SonarQube&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;JaCoCo plugin 후 jenkins 재시작&lt;/li&gt;
  &lt;li&gt;sonar-project.properties jacoco 항목 추가
    &lt;ul&gt;
      &lt;li&gt;sonar.jacoco.reportPath=build/jacoco/test.exec&lt;/li&gt;
      &lt;li&gt;sonar.dynamicAnalysis=reuseReports&lt;/li&gt;
      &lt;li&gt;sonar.surefire.reportsPath=tests/test-reports&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jenkins 프로젝트 구성 &amp;gt; 빌드 후 조치&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-4.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-4.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;build.gradle Jacoco 내용 추가&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jacoco&quot;&lt;/span&gt;
		...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

jacoco &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    toolVersion &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;0.8.5&apos;&lt;/span&gt;
    reportsDir &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; file&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$buildDir&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;/customJacocoReportDir&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

jacocoTestReport &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    reports &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        xml.enabled &lt;span class=&quot;nb&quot;&gt;false
        &lt;/span&gt;csv.enabled &lt;span class=&quot;nb&quot;&gt;false
        &lt;/span&gt;html.enabled &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    finalizedBy &lt;span class=&quot;s1&quot;&gt;&apos;jacocoTestCoverageVerification&apos;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

jacocoTestCoverageVerification &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    violationRules &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        rule &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            enabled &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
            &lt;/span&gt;element &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;CLASS&apos;&lt;/span&gt;

            limit &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                counter &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;LINE&apos;&lt;/span&gt;
                value &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&apos;COVEREDRATIO&apos;&lt;/span&gt;
//                minimum &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0.30
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            excludes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&apos;*.test.*&apos;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
            includes &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    finalizedBy &lt;span class=&quot;s1&quot;&gt;&apos;jacocoTestReport&apos;&lt;/span&gt;
		...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;JaCoCo code coverage build 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-5.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-5.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;JaCoCo code coverage test-reports 상세 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-6.png&quot; alt=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-basic-sonarqube-6.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참고 : 해당 기능은 프로젝트별 선택이며 도입 시 Coverage level 을 30% 이하 권장합니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 30 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2021/07/30/dev-doc-sonarqube/</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2021/07/30/dev-doc-sonarqube/</guid>
        
        <category>dev</category>
        
        <category>doc</category>
        
        <category>sonarqube</category>
        
        <category>docker</category>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>String StringBuilder StringBuffer</title>
        <description>&lt;h1 id=&quot;string-stringbuilder-stringbuffer-차이&quot;&gt;String StringBuilder StringBuffer 차이&lt;/h1&gt;

&lt;p&gt;String 은 immutable 입니다. 
String에 문자열을 더하거나 자르거나 할 떄마다 new String이 생성됩니다. (새로운 객체 생성)
그렇기 때문에 기존 값이 변하지 않으므로 String이 동기화 기능이 없더라도 멀티스레드나 여러 객체에서 공유할 때
안전하게 공유 될 수 있습니다. 값 변경이 적고 같은 값 참조를 많이 할 경우 좋습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연산자나 concat , substring을 사용 할 때 마다 기존 String이 변하는 것이 아니라 new String이 생성 됩니다. 그리고 그 이전의 String은 가비지 컬렉션에서 회수합니다. 이러한 작업들이 많아지면 힙에 garbage를 많이 생성하게 되고 성능이 떨어집니다.&lt;/li&gt;
  &lt;li&gt;연산자로 String을 더할 때 내부에서는 StringBuilder가 동작합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JDK 1.5 버전 이후에는 String 을 쓰더라도 StringBuilder로 컴파일이 됩니다. 하지만 반복 루프를 사용해서 문자열을 더할 떄는 객체를 계속 생성합니다. 그렇기 때문에 StringBuilder를 사용하는것이 더 좋습니다. (쓰지 않는 객체들이 메모리에 많이 쌓일 것입니다.)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
   &lt;span class=&quot;n&quot;&gt;myString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;myString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;bytecode view 를 하면&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javap -c className.class

public static void main(java.lang.String...);

Code:
0: ldc     #2   // String
2: astore_1    
3: iconst_0     
4: istore_2     
5: iload_2     
6: ldc     #3   // int 100
8: if_icmpge  36    
11: new     #4  // class java/lang/StringBuilder    
14: dup
15: invokespecial #5  // Method java/lang/StringBuilder.&quot;&amp;lt;init&amp;gt;&quot;:()V    
18: aload_1    
19: invokevirtual #6  // Method java/lang/StringBuilder.append:      
22: iload_2
23: invokevirtual #7  // Method java/lang/StringBuilder.append:
26: invokevirtual #8  // Method java/lang/StringBuilder.toString:    
29: astore_1
30: iinc    2, 1    
33: goto    5    
36: getstatic  #9  // java/lang/System.out:Ljava/io/PrintStream;
39: aload_1
40: invokevirtual #10  // Method java/io/PrintStream.println:    
43: return


The lines 5 and 33 is the for loop of the example. You can see that in the body of the loop a new StringBuilder is created (line 11), every time in the loop&apos;s body with the current contents of myString (line 19) and then the current value of i (line 23) is appended to the builder too. Then the current value of the StringBuilder is converted toString and myString gets this value assigned (line 26).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here you create the StringBuilder outside of the for loop, append the value of ito the builder and at the end you print out the result.Here the extra object creation will not take place.&lt;/p&gt;

&lt;p&gt;(String Literal)String을 생성하면 JVM String pool에 같은 값이 있는지를 찾고 같은 값이 존재한다면 해당 값의 reference를 반환합니다. 없다면 pool에 추가가 되고 reference를 반환합니다. (By String interning concept - storing only one copy of String in the pool)
이렇게 함으로 인해서 JVM은 여러 threads가 같은 String 값을 쓸 때에 불변이기 때문에 thread-safe 해서 동기화를 신경 안써도 되고 공간을 낭비하지 않을 수 있습니다.
(String Object) new() 를 사용하여 String 객체를 생성할 경우에는 언제나 새로운 객체를 heap memory에 생성합니다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;abc&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compare2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//false;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 지금은 한 번만 생성되었지만 수십번 String이 더해지는 경우에는 각 String의 주소값이 stack에 쌓이고 생성된 객체는 Garbage Collector가 호출되기 전까지 heap에 지속적으로 쌓이게 된다. 메모리 관리에 안좋다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Your example C is kind of different tho, because you&apos;re using the += operator which when compiled to bytecode it uses StringBuilder to concatenate the strings, so this creates a new instance of StringBuilder Object thus pointing to a different reference.
String is a final class with all the fields as final except “private int hash”. This field contains the hashCode() function value and created only when hashCode() method is called and then cached in this field. Furthermore, hash is generated using final fields of String class with some calculations, so every time hashCode() method is called, it will result in same output. For caller, its like calculations are happening every time but internally it’s cached in hash field.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;###StringBuilder와 StringBuffer는 mutable 입니다.&lt;/p&gt;

&lt;p&gt;문자열 연산이 있을때 기존의 버퍼(???) 크기가 변경 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The constructor with no parameters will create an instance of StringBuilder with the buffer size of 16. This is a default buffer size meaning it can contain 16 characters before it needs to be adjusted. When the buffer is full, StringBuilder will reallocate a new array which will have two times bigger capacity than the previous instance plus 2 additional buffer locations. 2n+2 
The StringBuffer and StringBuilder are implemented like an ArrayList (except dealing with an array of characters instead of an array of Object instances). When you add new content, if there’s capacity, then the content is added at the end; if not, a new array is created with double-plus-two size, the content backing store is copied to a new array, and then the old array is thrown away. As a result this step can take between O(1) and O(n lg n) depending on whether the initial capacity is exceeded.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;StringBuffer는 synchronized 합니다. 멀티스레드 환경에서도 동기화가 됩니다.&lt;/p&gt;

&lt;p&gt;동기화 처리로 인해 StringBuffer가 StringBuilder보다 성능이 좋지 않습니다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;performance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConcatTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;  
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Java&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;  
            &lt;span class=&quot;n&quot;&gt;sb&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Tpoint&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Time taken by StringBuffer: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sb2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Java&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++){&lt;/span&gt;  
            &lt;span class=&quot;n&quot;&gt;sb2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Tpoint&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Time taken by StringBuilder: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;ms&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;StringBuilder와 StringBuffer를 테스트 해보자. 
아래의 결과를 보면 다른 값이 나온 것을 볼 수 있다. 
StringBuilder의 값이 더 작은 것을 볼 수 있는데 이는 쓰레드들이 동시에 StringBuilder클래스에 접근할 수 있기 때문에 일어난 결과다. 
이와 달리 StringBuffer는 multi thread환경에서 다른 값을 변경하지 못하도록 하므로 web이나 소켓환경과 같이 비동기로 동작하는 경우가 많을 때는 StringBuffer를 사용하는 것이 안전할 것이다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;StringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StringBuffer.length: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;StringBuilder.length: &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stringBuilder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;printStackTrace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;결과: 
    StringBuffer.length: 77780
    StringBuilder.length: 76412&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Immutable Object는 불변객체로써, 값이 변하지 않는다. 변경하는 연산이 수행되면 변경하는 것처럼 보이더라도 실제 메모리에는 새로운 객체가 할당 되는 것이다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자바에서 Wrapper class에 해당하는 Integer, Character, Byte, Boolean, Long, Double, Float, Short 클래스는 모두 Immutable 이다.
그래서 heap에 있는 같은 오브젝트를 레퍼런스 하고 있는 경우라도, 새로운 연산이 적용되는 순간 새로운 오브젝트가 heap에 새롭게 할당된다.&lt;/p&gt;

&lt;p&gt;###이유는?
Integer클래스의 구현을 보면 final이라는 키워드가 붙어있다.
클래스의 붙어있는 final은 상속을 제한하는 목적으로 붙이는 제어자이다.
Integer클래스 내부에서 사용하는 실제 값인 value라는 변수가 있는데,
이 변수가 private final int value;로 선언되어있다.
즉, 생성자에 의해 생성되는 순간에만 초기화되고 변경불가능한 값이 된다.
이것 때문에 Wrapper class들도 Immutable한 오브젝트가 되는것이다.&lt;/p&gt;

&lt;p&gt;Heap
-Heap영역에는 주로 긴 생명주기를 가지는 데이터들이 저장된다.
-애플리케이션의 모든 메모리 중 stack에 있는 데이터를 제외한 부분이라고 보면 된다.
-모든 Object 타입(Integer, String,ArrayList, …)은 heap 영역에 생성된다.
-단 하나의 Heap영역만 존재한다.
-Heap영역에 있는 오브젝트들을 가리키는 레퍼런스 변수가 stack에 올라가게 된다.&lt;/p&gt;

&lt;p&gt;Stack&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Heap 영역에 생성된 Object 타입의 데이터의 참조값이 할당.&lt;/li&gt;
  &lt;li&gt;원시타입의 데이터가 값과 함께 할당된다.&lt;/li&gt;
  &lt;li&gt;지역변수들은 scope에 따른 visibility를 가진다.&lt;/li&gt;
  &lt;li&gt;각 Thread는 자신만의 stack을 가진다.(공유는 되지않음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;변수 scope (가시성, Visibility)
-프로그램 내 변수에 접근할 수 있는 유효 범위/영역
:정의된 변수가 보이는 유효 범위
Stack에는 heap영역에 생성된 Object 타입의 데이터들에 대한 참조를 위한 값들이 할당.
원시타입의 데이터들이 할당, 이때 원시타입의 데이터들에 대해서는 참조값을 저장하는것이 아니라 실제 값을 stack에 직접 저장하게 된다.&lt;/p&gt;

&lt;p&gt;Stack메모리는 Thread 하나당 하나씩 할당된다. 즉, 새로운 스레드가 생성되는 순간 해당 스레드를 위한 stack도 함께 생성된다.
각 스레드에서 다른 스레드의 stack영역에는 접근할 수 없다.&lt;/p&gt;

&lt;p&gt;String one = “someString”; 
JVM 스택에 생성된 변수 one은 힙 메모리에 생성된 객체를 참조하며, 객체는 다시 메소드 메모리에 있는 상수풀(String Liberal Pool)을 참조한다. syntax에는 객체 생성 연산자인 new를 쓰지 않지만, 내부적으로는 객체를 생성한다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그림에는 문자열 리터럴(“someString”)이 객체에 생성된 것처럼 보이나 실제로는 상수풀에 생성되며, 객체는 상수풀을 참조하는 주소값만 가진 것으로 볼 수 있다. 따라서 (1)은 변수(JVM 스택), 객체(힙 메모리), 상수풀(메소드)이 서로 참조를 통해 긴밀히 연결된 일종의 네트워크다.&lt;/p&gt;

&lt;p&gt;String two = new String(“someString”);
string object on the heap, and having a reference to it from the string pool&lt;/p&gt;

&lt;p&gt;반면에 == 연산의 경우 객체의 주소값을 비교합니다. 그렇기때문에 new 연산자를 통해 Heap 영역에 생성된 String과 리터럴을 이용해 String Constant Pool 영역에 위치한 String과의 주소값은 같을 수가 없지요.&lt;/p&gt;

&lt;p&gt;Spring Constant Pool
상수풀(Spring Constant Pool)의 위치는 Java 7 부터 Perm영역에서 Heap 영역으로 옮겨졌습니다. Perm영역은 실행시간(Runtime)에 가변적으로 변경할 수 없는 고정된 사이즈이기 때문에 intern 메서드의 호출은 저장할 공간이 부족하게 만들 수 있었습니다. 즉 OOM(Out Of Memory) 문제가 발생할 수 있었지요. Heap 영역으로 변경된 이후에는 상수풀에 들어간 문자열도 Garbage Collection 대상이 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관련 링크) JDK-6962931 : move interned strings out of the perm gen(Oracle Java Bug Database)
&lt;a href=&quot;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6962931&quot;&gt;https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6962931&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;번외로 Java 7버전에서 상수풀의 위치가 Perm영역(정확히 말하면 Permanent Generation)에서 Heap으로 옮겨지고 Java 8 버전에서는 Perm영역은 완전히 사라지고 이를 MetaSpace라는 영역이 대신하고 있습니다.&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2021/07/30/dev-basic-java-string/</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2021/07/30/dev-basic-java-string/</guid>
        
        <category>dev</category>
        
        <category>basic</category>
        
        <category>String</category>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>REST API의 이해</title>
        <description>&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/post_img/2020-12-30-dev-doc-rest-1.png&quot; alt=&quot;그림1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;rest-api의-이해&quot;&gt;REST API의 이해&lt;/h1&gt;
&lt;h4 id=&quot;feat-그런-rest-api로-괜찮은가---deview-2017&quot;&gt;&lt;strong&gt;&lt;em&gt;feat. 그런 REST API로 괜찮은가 - DEVIEW 2017&lt;/em&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;“Representation State Transfer” are a way of providing interoperability between computer systems on the Internet. 인터넷상의 컴퓨터 시스템간에 상호 운용성을 제공하는 방법.. 즉, 자원을 자원의 표현으로 구분하여 정보를 주고받는 모든것을 의미하며, www과 같은 분산 하이퍼미디어 시스템을 위한 소프트웨어 아키텍처의 한 형식이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;배경&lt;br /&gt;
HTTP를 명세한 주요 저자 중 한 사람인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Roy_Fielding&quot;&gt;Roy Fielding&lt;/a&gt;은 현재의 아키텍처가 WEB의 본래 설계의 우수성을 많이 사용하지 못하고 있다고 생각했다. 로이는 &lt;strong&gt;&lt;em&gt;“WEB의 장점을 최대한 활용하며 어떻게 독립적으로 WEB을 보존하면서 진보시킬 수 있을까?”&lt;/em&gt;&lt;/strong&gt; 고민끝에 REST의 기반이 되는 &lt;em&gt;HTTP Object Model&lt;/em&gt; 이론을 마이크로소프트 Research에서 발표하게 되면서 시작됐다. 2년 뒤 2000년에 박사과정중이었던 로이는 현재 우리가 알고있는 “Representation State Transfer”를 120Page 분량의 박사논문에 정의하여 발표하게된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;선택&lt;br /&gt;
WEB에 API 개념이 생겨나면서 마이크로소프트는 XML을 이용하여 원격으로 다른 시스템에 메소드를 호출할 수 있는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/XML-RPC&quot;&gt;프로토콜(XML-RPC)&lt;/a&gt;를 만들고 &lt;a href=&quot;https://ko.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;(Simple Object Access Protocol)란 이름으로 변경한다. 2000년 SOAP를 이용한 salesforce API가 나타나고 4년후 REST를 이용한 flickr API와 비교가 되며 REST의 단순하고 규칙적고 쉬운 환경에 업계는 서비스의 대부분의 API를 REST로 대체한다. EMC와 IBM, 마이크로소프트 등 글로벌 거대 벤더들이 웹서비스와 웹 2.0 인터페이스를 기반으로 공동 개발한 CMIS(Content Management Interoperability Services: 콘텐츠 관리 상호 운용 서비스) 규격 을 발표하고, 마이크로소프트에서는 우리가 흔히 알고있는 REST API
의 가이드라인을 만들어 발표하기까지 이른다.&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - uri는 http://{sericeRoot}/{collection}/{id} 형식이어야함
  - GET,PUT,DELETE,POST,HEAD,PATCH,OPTIONS 를 지원해야함  
  - API 버저닝은 Major.minor로 하고 uri에 버전 정보를 포함시킨다. 등등..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;하지만.. 필딩은 모두 REST가 아니다고 얘기한다. 뭐지.. REST 아키텍처 스타일을 따르지 않았단다. REST API를 위한 최고의 버저닝 전략은 버저닝을 안하는것이며, REST API는 하이퍼텍스트 기반이어야 한다는것이다. 위언급했듯 REST는 분산 하이퍼 미디어 시스템(WEB) 을 위한 아키텍처 스타일이다. 아키텍처 스타일은 일종의 제약조건들의 집합인데 이 요소들을 하이브리드 아키텍처스타일로 구성되어야한다는것이다. REST 구성의 제약조건은 다음과 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;client-server&lt;/strong&gt; : 자원을 갖고 있는 Server와 그 자원을 요청하는 Client 관계에서 서버는 API를 제공하고 비즈니스 로직 처리 및 데이터저장의 책임을 지니고, 클라이언트에서 컨텍스트정보들은 자기가 직접관리하여 서로간의 의존성이 줄어든다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;stateless&lt;/strong&gt; : Client의 컨텍스트정보들을 Server에 저장하지 않아서 세션과 쿠키와 같은 context 정보를 신경쓰지 않아도 되므로 구현이 단순해진다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;cacheable&lt;/strong&gt; : WEB에서 사용하는 기존의 인프라를 그대로 활용가능.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;uniform interface&lt;/strong&gt; : HTTP 표준에만 따른다면, 어떠한 기술이든 적용 가능.
 		- identification of resources : 리소스가 uri로 식별기능.
     - manipuation of resources through representations : 메세지로 리소스 CRUD제어가능.
     - self-descriptive messages : 메세지는 스스로 설명 할 줄 알아야함.
     - hypermedia as the engine of application state(HATEOAS) : 애플리케이션의 상태는 Hyperlink를 이용해 전이 되어야한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;layered system&lt;/strong&gt; : Client ► 보안,로드밸런싱,암호화,사용자인증 등 유연한 구조가 가능. ► 순수 비지니스로직 API Server ► 다중계층으로 구성가능.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;code-on-demand&lt;/strong&gt;(optional) : 서버의 코드를 클라이언트에서 운영가능.(ex. 자바스크립트)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로이필딩은 현재 위 REST 제약조건에 따르지않고 HTTP API 형태 임에도 불구 명칭을 REST-API라고 칭하는 관계자들에게 제발 제약도건에 따르던제 아니면 다른단어를 써라라고 전달했다. 하지만 사실 구조가체가 다르다. REST를 따를수있는 대샹이 웹페이지와 HTTP API 는 기계와 사람이기때문에 mediaType 이 시각적인 측면에서 html과 json으로 구분되기 때문이다. 
예를들어 HTML의 Self-descriptive는 응답메세지의 Content-Type이 text/html임을 확인이 되면 HTTP 명세에 media type IANA에 등록되어있고, IANA에서 text/html의 설명을 찾는다. text/html 명세에는 http://www.w3.org/TR/html 의 링크에 명세 해석이 가능하다. 
HATEOAS 조건또한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;a href=&quot;&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt; 태그를 이용해 표현된 링크를 통해 다음상태로 전달될 수 있으므로 HATEOAS를 만족한다. 반면에 JSON도 media type이 application/json 으로 표현되어 IANA에 등록도 되어있고 관련 링크를 찾아가 json 문서를 파싱하여 해석도가능하다. 하지만 내용의 정확한 속성 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex) [{&quot;op&quot;:remove,&quot;path&quot;:&quot;/a/s/d&quot;}]&lt;/code&gt; “op”나 “path”의 각 의미들이 무엇을 의미하는지는 알수없어서 온전한 해석이 불가능하기 때문에 Self-descriptive 하지않고 다음 상태로 전이 할 링크가 없으므로 HATEOAS 또한 하지않다.&lt;/p&gt;

&lt;p&gt;REST는 SOAP보다 사용하기 쉽고 간편한줄만 알았는데 복잡하고 어렵다. 사실 REST 제약조건을 모두 맞춰가며 시스템을 구현하는 RESTful 사례가 적다. 그래서 이렇게 굳이 제약조건을 전부 따져가며 구축을해야 하는가? 로이필드는 “시스템 전체를 통제(서버와 클라이언트를 전체를 제어)할 수 있다고 생각하거나, 진화에 관심이 없다면 REST에 대해 따지느라 시간을 낭비하지 말았으면한다.”라고 답변했다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;&lt;em&gt;그럼 Self-descriptive 와 HATEOAS를 만족할 수 있는방법은?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Self-descriptive은 Media type을 IANA에 등록 하여 custom media type이나 profile link relation 등으로 만족.&lt;/li&gt;
  &lt;li&gt;HATEOAS는 HTTP 헤더나 본문에 &lt;strong&gt;링크&lt;/strong&gt; 를 담아 REST의 조건을 만족.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Media type을 IANA에 등록을 꼭 해야하는건 아니다. 하지만 등록을하면 여러이점이있는데 누가나 쉽게 사용할 수 있고, 이름 충돌을 피할 수 있으며, 등록은 어렵지 않다고? 한다.&lt;/p&gt;

&lt;p&gt;오늘날의 RESTAPI는 REST를 거의 따르지않는다. 제약조건중에서 특히 &lt;strong&gt;Self-descriptive&lt;/strong&gt; 와 &lt;strong&gt;HATEOAS&lt;/strong&gt; 를 만족하기 힘들기 때문이다. 그래도 REST를 따르며 API를 설계하겠다면 조건을 만족시켜 설계하시기 바랍니다.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/REST&quot;&gt;https://ko.wikipedia.org/wiki/REST&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.toss.im/2017/10/25/team/people/toss-developer-deview-conference/&quot;&gt;https://blog.toss.im/2017/10/25/team/people/toss-developer-deview-conference/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot;&gt;https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 27 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/dev/2021/07/27/dev-doc-rest/</link>
        <guid isPermaLink="true">http://localhost:4000/dev/2021/07/27/dev-doc-rest/</guid>
        
        <category>dev</category>
        
        <category>doc</category>
        
        <category>rest</category>
        
        
        <category>dev</category>
        
      </item>
    
      <item>
        <title>[리뷰] 리팩터링 2판</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;한빛미디어&lt;/code&gt; 출판사의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;리팩터링 2판(마틴 파울러 저/개앞맵시, 남기혁 역)&quot;&lt;/code&gt;을 읽고 작성한 리뷰입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-1.jpg&quot; alt=&quot;표지&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;개정판을 소개하기 앞서 약 20년전의 초판에 대해 잠깐 설명하려 한다. 2000년 초반 학부시절 어렵사리 초판을 원서로 구했다. 미학과는 거리가 멀어보이는 딱딱해보이는 S/W 아키텍처 설계에 예술같은 개념이 숨어있다는 것에 적잖이 놀랐고, 그동안 등한시 했던 철학에 대한 새로운 시각이 정립된 것은 신선한 충격이었다.&lt;/p&gt;

&lt;p&gt;되지도 않는 영어와 씨름하며 열심히 읽었던 덕분에 당시 국내에는 생소했던 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OOP의 다형성 및 상속구조에 대한 개념&lt;/code&gt;을 동년배들에 비해 빠르게 다질 수 있어 이후의 프로그래밍 실무가 정말 편했다.&lt;/p&gt;

&lt;p&gt;세월이 흘러 Spring 프레임워크가 등장했을 때에도 저자 마틴 파울러의 철학이 이미 녹아있었던 덕분인지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DI 및 IoC와 같은 커다란 변화&lt;/code&gt;도 쉽게 이해할 수 있었다.&lt;/p&gt;

&lt;p&gt;뿐만이랴. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;리팩토링 자체에 대한 실무는 물론 테스트 코드 작성, 디자인 패턴&lt;/code&gt; 등 대부분의 OOP 프로그래밍에 있어 개념적으로 헤매인 기억은 없는 듯 하다.&lt;/p&gt;

&lt;p&gt;이렇게 초판을 구구절절 칭찬하는 이유는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이제 중견의 나이에 접어든 한 독자가 20년에 걸친 산 증인으로 본 도서가 개발에 얼마나 많은 도움을 주었는지 언급하는 것이 후배 프로그래머들에게 제일 도움이 되리라는 판단&lt;/code&gt;에서다.&lt;/p&gt;

&lt;p&gt;초판의 장점은 2판에 있어서도 역시 유효하다. 초판을 읽고 나름 실무의 내공이 쌓인 덕인지 2판은 정말 쉽게 술술 읽혔다. 대부분의 프로그래머라면 자질구레한 이론보다는 먼저 코드로 설명하길 원할 것이다.&lt;/p&gt;

&lt;p&gt;마틴 파울러는 1장부터 이론적 설명 보다는 아래 그림과 같은 예제 코드를 제시하고 직접 리팩토링이 무엇인지 느낄 수 있도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;바로 실습부터&lt;/code&gt; 진행한다. 
&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-7.jpg&quot; alt=&quot;표지&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;본 리뷰도 이를 본받아 실무에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 책을 읽는 사용하는 방법&lt;/code&gt;부터 설명하고자 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;먼저 &lt;부록B&gt;부터 보자. 내가 맡은 프로그램에 이런 유형의 악취가 풍기면 해당절을 읽으면 된다.&lt;/부록B&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-2.jpg&quot; alt=&quot;악취유형&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;첫번째 제시된 해결기법인(빨간색 네모 안)의 변수 캡슐화하기를 보면 6.6절을 참고하라고 안내되어있다. 해당절로 이동하면 직관적인 그림 하나가 눈에 들어온다. 
&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-3.jpg&quot; alt=&quot;해결기법 세부&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;해당 유형의 리팩토링을 한 3번 정도 해보면 나중엔 그림만 봐도 실무에서 어떤 기법으로 리팩토링할지 바로 감이 잡힌다. 잘 기억이 안나면 그 밑의 아주 간단한 코드의 변화를 보면 거의 99% 바로 이해된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 악취의 유형 자체가 이해가 가지 않는다면 3장(코드에서 나는 악취)로 넘어가 가변데이터 부분을 읽으면 이해가 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;다시 돌아와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;책을 읽는 방법&lt;/code&gt;을 설명하고자 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1장&lt;/code&gt;은 제일 먼저 반드시 읽어야 하는 부분이고 아마 경력 1년정도 제대로 프로그래밍을 경험하신 분이라면 재미있게 2시간 정도면 읽을 수 있을거라 본다. 실무에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;가장 자주 사용하는 리팩토링 기법&lt;/code&gt;들로 구성되어 있는데 간단히 설명하면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;반복문쪼개기 + 문장슬라이드 + 함수추출 + 변수인라인&lt;/li&gt;
  &lt;li&gt;중첩함수 난무 제거 : 중간데이터 클래스 활용&lt;/li&gt;
  &lt;li&gt;다형성 적용 : .js 특성을 고려해 factory 패턴 활용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2장&lt;/code&gt;에는 리팩토링을 적용 시 실무에서 고려할 사항 등 관련된 이론 전부가 짧은 페이지안에 다 녹아있다. 이론이 이렇게 짧은 책은 정말 처음본다. 그런데 필요한 내용은 다 들어있다.&lt;/p&gt;

&lt;p&gt;예를 들면 아래 그림은 브랜치에 관한 설명이다. 개인적으로 GitHub 사용하며 봉착했던 문제와 해결책이 이 반쪽에 전반적으로 다 들어있다. 이를 통해 결론적으로 리팩토링을 효율적으로 사용하기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CI + TDD 개발방식&lt;/code&gt;을 추천한다는 내용이다.
&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-6.jpg&quot; alt=&quot;브랜치&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3장&lt;/code&gt;은 위에서 언급했다. 악취의 유형과 맡는 방법에 대한 설명인데 이게 무슨 말이냐? 리팩토링은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;언제&lt;/code&gt;해야 하는지에 대한 가이드라고 보면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4장&lt;/code&gt;은 솔직히 감동이었다. 테스트 코드 작성의 중요성은 굳이 강조하지 않겠다. 2장에서 중요성을 언급했던 것에 대한 책임감인지 테스트 구축 방법을 안내한다.
&lt;img src=&quot;https://shimdaniel.github.io/assets/img/review/2020-04-26-review-book-refactoring-2nd-4.jpg&quot; alt=&quot;테스트&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5장&lt;/code&gt;은 겨우 2페이지이므로 가볍게 읽으시면 된다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6장 ~ 12장&lt;/code&gt;이 본 게임인데 양이 많다고 기죽지 마시길. 괜히 처음부터 읽느라 기운뺄 필요는 없다. 실무에서 필요성이 감지되면 위에서 안내한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;이 책을 읽는 사용하는 방법&lt;/code&gt;대로 진행하시면 된다.&lt;/p&gt;

&lt;p&gt;굳이 너무 읽고싶어 못참겠다면 먼저 그림과 코드 정도만 빠르게 읽어 머리속에 메타지도를 완성하시면 실무에 도움이 될 수 있을듯 하다.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;책의 장점은 20년동안 필자를 비롯한 산증인(?)들에 의해 검증이 되었다고 요약하며 끝내고 싶지만, 읽지 않았던 분들을 위해 개인적으로 인상깊었던 부분을 간단히 짚고 넘어가겠다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리팩토링 기법도 중요하지만 사실 제일 좋은 방법은 리팩토링이 생길 여지를 주지 않는 것이다. 즉, 설계적 안목이 굉장히 중요한데 그 어떤 서적보다 빠르게 정립할 수 있다.
    &lt;blockquote&gt;
      &lt;p&gt;(예 75p 中) “서브클래스를 언제 사용하면 좋은지 감이 잡힐 것이다.”&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램 개발 시 완성 속도는 빠를지 몰라도 거지같이 만들어서 유지보수를 힘겹게 만드는 현상을 두고 흔히들 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기술적 부채(Technical debt)&lt;/code&gt;라고 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특히, 한국의 거지같은 SI 문화가 이를 지향하는데 쉽게 말해 10명이 개발해야 하는 것을 1명이 개발하는 오너의 마법이다. 파는 사람 입장에서야 단가 후려치기에 있어 최고 스킬이겠지만, 사는 사람 입장에서는 1명이 유지보수 할 수 있는 것 10명 인건비 주며 유지보수 해야하는 셈이다.&lt;/p&gt;

&lt;p&gt;이 책을 읽으면 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기술적 부채(Technical debt)&lt;/code&gt;가 거의 쌓이지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;속도에 대한 개념이 하나 추가된다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(컴퓨터의) 연산속도 + (사람의) 개발 속도&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;1분만에 돌아가는 100시간동안 만든 프로그램 vs 10분만에 돌아가는 10시간만에 만든 프로그램&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;철학에 대한 개념 재정립.
    &lt;ul&gt;
      &lt;li&gt;멀리있지 않다는 것, 정말 중요하다는 것을 일깨워 준다. (본 도서에 철학이라는 단어는 거의 등장하지 않음에도)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;기타의견
    &lt;ul&gt;
      &lt;li&gt;번역의 품질이 아주 우수하다.&lt;/li&gt;
      &lt;li&gt;20년만의 개정판은 많은 의미를 내포한다.
        &lt;ul&gt;
          &lt;li&gt;20년 동안 쓸만했다는 것과, 20년 동안 많은 이들이 읽었다는 것(유용했다는 것), 그리고 개정판을 원하는 이가 많았다는 것 등..&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;실습예제가 .java에서 .js로 변경되었다.
        &lt;ul&gt;
          &lt;li&gt;async 및 await, promise 등의 js에 특화된 내용은 다루지 않는다. (프로그램 일반화에 초점을 맞추고 js에 초점을 맞추진 않는다.)&lt;/li&gt;
          &lt;li&gt;단, 구현 특성 상 덕타이핑, 최상위 클래스 제약 등은 사전에 알면 도움이 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;마치며&lt;/strong&gt;&lt;br /&gt;
구구절절한 말은 필요없다. 프로그래머라면, 예비 프로그래머라면, 프로그램 만들고 싶다면, 관심있다면 반드시 읽어라.&lt;/p&gt;

    &lt;p&gt;안 읽으면? 당신만 손해다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/89649360?Acode=101&quot;&gt;책소개 - 리팩터링 2판 : 코드 구조를 체계적으로 개선하여 효율적인 리팩터링 구현하기&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 26 Jul 2021 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/review/2021/07/26/review-book-refactoring-2nd/</link>
        <guid isPermaLink="true">http://localhost:4000/review/2021/07/26/review-book-refactoring-2nd/</guid>
        
        <category>review</category>
        
        <category>book</category>
        
        <category>Refactoring</category>
        
        <category>Improving</category>
        
        <category>the</category>
        
        <category>Design</category>
        
        <category>of</category>
        
        <category>Existing</category>
        
        <category>Code</category>
        
        <category>리팩터링</category>
        
        
        <category>review</category>
        
      </item>
    
  </channel>
</rss>
